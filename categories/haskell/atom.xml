<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | Danny Navarro's blog]]></title>
  <link href="http://dannynavarro.net/categories/haskell/atom.xml" rel="self"/>
  <link href="http://dannynavarro.net/"/>
  <updated>2014-03-12T16:31:15+01:00</updated>
  <id>http://dannynavarro.net/</id>
  <author>
    <name><![CDATA[Danny Navarro]]></name>
    <email><![CDATA[j@dannynavarro.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improving readability with the Maybe Foldable instance]]></title>
    <link href="http://dannynavarro.net/2014/03/12/improving-readability-with-the-maybe-foldable-instance/"/>
    <updated>2014-03-12T12:00:00+01:00</updated>
    <id>http://dannynavarro.net/2014/03/12/improving-readability-with-the-maybe-foldable-instance</id>
    <content type="html"><![CDATA[<p>One recommendation you often hear when reaching an acceptable level of basic
Haskell is to make your code more polymorphic. The Haskell <a href="http://hackage.haskell.org/package/base/docs/Prelude.html"><code>Prelude</code></a> is
heavily biased towards lists, so an immediate gain in polymorphism is to make
your code work not only for lists but for any instance of <a href="http://hackage.haskell.org/package/base/docs/Data-Traversable.html"><code>Traversable</code></a> or
<a href="http://hackage.haskell.org/package/base/docs/Data-Foldable.html"><code>Foldable</code></a>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Since a Haskell list is an instance of <a href="http://hackage.haskell.org/package/base/docs/Data-Traversable.html"><code>Traversable</code></a> and <a href="http://hackage.haskell.org/package/base/docs/Data-Foldable.html"><code>Foldable</code></a>, we can
still operate as usual on lists with the new polymorphic code:</p>

<p>``` haskell</p>

<blockquote><blockquote><blockquote><p>import qualified Data.Foldable as F
mapM<em> print [&lsquo;a&rsquo;..&lsquo;c&rsquo;]
&lsquo;a&rsquo;
&lsquo;b&rsquo;
&lsquo;c&rsquo;
F.traverse</em> print [&lsquo;a&rsquo;..&lsquo;c&rsquo;]
&lsquo;a&rsquo;
&lsquo;b&rsquo;
&lsquo;c&rsquo;
```</p></blockquote></blockquote></blockquote>

<p>Notice here that we&rsquo;ve gained the extra advantage of being able to use <code>Applicative</code>
instead of <code>Monad</code>. Here, we don&rsquo;t need the extra power of <code>Monad</code>, and the
<code>Applicative</code>, by being weaker, is also more generalizable.</p>

<p>But aside of lists, there is another instance of <code>Traversable</code>/<code>Foldable</code>
defined by default for us: <code>Maybe</code>. You could think of a <code>Maybe</code> as a list of 1
or 0 elements, so when you are traversing it you either do something with the
element if present or do the default <code>Applicative</code>/<code>Monad</code> action (<code>pure</code> and
<code>return</code> respectively) if not present. How is this useful then? Have you ever
found yourself writing case expressions like this?</p>

<p>``` haskell</p>

<blockquote><blockquote><blockquote><p>:{
let printM m = case m of</p>

<pre><code>                Just n  -&gt; print n
                Nothing -&gt; return ()
</code></pre>

<p>:}
let m1 = Just 1 :: Maybe Int
let m<em> = Nothing :: Maybe Int
printM m1
1
printM m</em></p>

<p>```</p></blockquote></blockquote></blockquote>

<p>The function <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#v:maybe"><code>maybe</code></a> would improve a bit, syntactically speaking: <code>maybe
(return ()) print</code>.</p>

<p>Maybe it&rsquo;s just me, but that <code>return ()</code> <a href="https://en.wikipedia.org/wiki/Code_smell">smells</a> too much of a default
behavior to me. Somehow, there should be a way to avoid it. Well, here is where
<a href="http://hackage.haskell.org/package/base/docs/Data-Foldable.html"><code>Foldable</code></a> instance of <code>Maybe</code> comes handy:</p>

<p>``` haskell</p>

<blockquote><blockquote><blockquote><p>:set -XScopedTypeVariables
let printM' :: Maybe Int &ndash;> IO () = F.traverse<em> print
printM' m1
1
printM' m</em></p>

<p>```</p></blockquote></blockquote></blockquote>

<p>To be fair, for this trivial example, it would be a bit frivolous to use the
<code>Maybe</code> <code>Foldable</code> instance just to avoid the case expression, but when you are
in an intricate case expression ladder, this idiom can make your code much more
readable.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Roughly speaking, the <code>Traversable</code> instance would be used for operations that do something on each element of the structure while maintaining same structure in the output. A <code>Foldable</code> instance would be used for collapsing the elements into anything else.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
