<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Danny Navarro&#39;s Blog</title>
    <description>Mostly Haskell ramblings</description>
    <link>http://dannynavarro.net/</link>
    <atom:link href="http://dannynavarro.net/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 21 Jan 2016 12:43:55 +0100</pubDate>
    <lastBuildDate>Thu, 21 Jan 2016 12:43:55 +0100</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Picking Lower Bounds Versions for your Dependencies</title>
        <description>&lt;p&gt;I always get an uneasy feeling when explaining this topic to new&lt;br /&gt;
programmers. I limit myself to something along these lines: “In this case&lt;br /&gt;
I’m choosing these versions because of &lt;em&gt;this&lt;/em&gt; and &lt;em&gt;that&lt;/em&gt;, were the&lt;br /&gt;
circumstances different I would probably have chosen differently”. In&lt;br /&gt;
these sessions I try to stick to the act of coding so I try to not digress&lt;br /&gt;
too much into such hairy matters as version management. Nevertheless, I&lt;br /&gt;
think a decent criterion for picking these versions is something important&lt;br /&gt;
for a developer expected to work independently.&lt;/p&gt;

&lt;p&gt;I don’t think a precise guide could be written on the topic. The ability&lt;br /&gt;
comes naturally with experience and some common sense. In this post I’ll try&lt;br /&gt;
try to bring forward some factors to weight in when choosing the minimal&lt;br /&gt;
dependency versions.&lt;/p&gt;

&lt;p&gt;For concrete examples I’m focusing on the Haskell ecosystem, where I’m&lt;br /&gt;
spending most of my time these days, but I guess it could be directly&lt;br /&gt;
translated to other ecosystems.&lt;/p&gt;

&lt;p&gt;I’m assuming the word &lt;em&gt;package&lt;/em&gt; is a unit of code shipped with a version&lt;br /&gt;
number. In Haskell this is a &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal package&lt;/a&gt;, but it could be a&lt;br /&gt;
&lt;a href=&quot;http://pythonwheels.com/&quot;&gt;Python wheel&lt;/a&gt;, a &lt;a href=&quot;http://guides.rubygems.org/rubygems-basics/&quot;&gt;Ruby gem&lt;/a&gt;, or a &lt;a href=&quot;https://crates.io/&quot;&gt;Rust crate&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;deployment&quot;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;There are 2 non-mutually exclusive broad categories here, although the&lt;br /&gt;
distinction can get quite blurry.&lt;/p&gt;

&lt;h3 id=&quot;push-based&quot;&gt;Push-based&lt;/h3&gt;

&lt;p&gt;In this kind of deployment you are directly &lt;em&gt;pushing&lt;/em&gt; your code into an&lt;br /&gt;
environment where it’ll be built&lt;sup id=&quot;fnref:e&quot;&gt;&lt;a href=&quot;#fn:e&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and executed. Here you have precise&lt;br /&gt;
knowledge of the environment where your code will run.&lt;/p&gt;

&lt;p&gt;This is the typical setting for web server applications. In this case, version&lt;br /&gt;
bounds are not so important, it’s alright to just set the minimum versions&lt;br /&gt;
to the ones you are using for development. However in this scenario it’s&lt;br /&gt;
almost always a good idea to pin all the dependency when building. You&lt;br /&gt;
want deterministic repeatable builds and avoid nasty surprises, specially&lt;br /&gt;
when dependencies get updated. For most packaging systems there is always&lt;br /&gt;
some mechanism for freezing versions outside the package specification.  In&lt;br /&gt;
Haskell you can manually&lt;sup id=&quot;fnref:f&quot;&gt;&lt;a href=&quot;#fn:f&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; pin dependency versions in the &lt;code class=&quot;highlighter-rouge&quot;&gt;cabal.config&lt;/code&gt; or you&lt;br /&gt;
can use &lt;a href=&quot;https://www.stackage.org/&quot;&gt;Stackage&lt;/a&gt; and &lt;a href=&quot;https://github.com/commercialhaskell/stack&quot;&gt;stack&lt;/a&gt; to manage version dependency sets smoothly.&lt;/p&gt;

&lt;p&gt;At the package level you want to maintain maximum flexibility so that you can&lt;br /&gt;
test different dependency versions easily, specially to get early warnings when&lt;br /&gt;
dependencies are updated. You could think of the versions limits in the core&lt;br /&gt;
package specification as the versions that will never be picked, no matter the&lt;br /&gt;
circumstance.&lt;/p&gt;

&lt;h3 id=&quot;pull-based&quot;&gt;Pull-based&lt;/h3&gt;

&lt;p&gt;In this case you are packing your code and uploading it to some kind of&lt;br /&gt;
central package repository. Consumers will &lt;em&gt;pull&lt;/em&gt; the package and install&lt;br /&gt;
it on their system. Your code will run on systems that are outside of your&lt;br /&gt;
control.&lt;/p&gt;

&lt;p&gt;A frequent use case is to support as many target users as possible.&lt;br /&gt;
Often enough, the users will run your code on very heterogeneous&lt;br /&gt;
environments and you don’t want them to step into any problems when trying&lt;br /&gt;
your new shiny package.&lt;/p&gt;

&lt;p&gt;By default it’s wise to aim for low dependency versions, but you don’t need&lt;br /&gt;
to go as far low as possible. It’s usually a good idea to target the&lt;br /&gt;
lowest versions that are still getting maintenance upgrades (more about&lt;br /&gt;
this later). For example, in the case of Haskell, unless you have a&lt;br /&gt;
specific reason, I think it’s reasonable to tell your users that you are&lt;br /&gt;
not supporting GHC-7.4.3 (Haskell compiler) anymore. You can select&lt;br /&gt;
the version cut-off based on the fact that the oldest GHC version of the&lt;br /&gt;
major Linux distributions, is &lt;a href=&quot;https://packages.debian.org/jessie/ghc&quot;&gt;GHC-7.6.3&lt;/a&gt;, in Debian Jessie&lt;sup id=&quot;fnref:a&quot;&gt;&lt;a href=&quot;#fn:a&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;. But your&lt;br /&gt;
mileage may vary, it all depends on the users you are targeting. The more&lt;br /&gt;
data you have about them, the better you’d be able to make these kind of&lt;br /&gt;
decisions.&lt;/p&gt;

&lt;p&gt;In my experience, for pull-based packages, it’s best to build and test&lt;br /&gt;
your code with both the maximum and minimum versions at the same time. If&lt;br /&gt;
running both tests takes too long, you can move one test suite, the&lt;br /&gt;
minimum one usually, to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot;&gt;CI&lt;/a&gt; system. In any case, it only makes sense to test&lt;br /&gt;
both the latest and the oldest sets of dependencies, don’t bother trying&lt;br /&gt;
different set combinations unless you have a very specific reason, I’ll explain&lt;br /&gt;
why below.&lt;br /&gt;
&lt;!---
In the case of GHC, I often use Debian as the central authority I trust to
set the minimum lower bounds. But your choice of maintenance authority can
be very different. Ideally, having real data of the environment your users
users have will help you make better decisions. You&#39;d also have to take
into account factors like whether you want to force users to upgrade? Did you
give them enough deprecation warnings with enough time to not piss them
off? But handling API upgrades is outside the scope of this post.
--&gt;&lt;/p&gt;

&lt;h2 id=&quot;release-channels&quot;&gt;Release Channels&lt;/h2&gt;

&lt;p&gt;For new libraries there is just a single channel following the latest&lt;br /&gt;
version, but for more mature ones you can usually identify at least an&lt;br /&gt;
extra channel with more conservative releases. Notice here that even if&lt;br /&gt;
the original authors don’t explicitly maintain multiple channels, you can&lt;br /&gt;
still find downstream packagers that do keep releasing&lt;br /&gt;
security/performance fixes while maintaining a frozen API. And even&lt;br /&gt;
without 3rd party packagers it’s possible to distinguish virtual&lt;br /&gt;
channels with some implicit knowledge gained by social means. For example,&lt;br /&gt;
do you know which version is mostly used by the community? or what early&lt;br /&gt;
adopters are reporting when trying newer versions? It’s good to follow bug&lt;br /&gt;
reports, mailing lists or relevant forums to get a sense of the stability of&lt;br /&gt;
the packages.&lt;/p&gt;

&lt;p&gt;How aggressively new features get released on each channel vary greatly&lt;br /&gt;
between authors and communities. Some communities are notoriously&lt;br /&gt;
disciplined about maintaining strict release policies but you should&lt;br /&gt;
always keep an eye for authors breaking ranks. In general, you can always&lt;br /&gt;
assume that with new features inevitably come new bugs.&lt;/p&gt;

&lt;p&gt;Sometimes, the build with the minimum version dependencies represents the most&lt;br /&gt;
stable &lt;em&gt;edition&lt;/em&gt; of your code (instead of just providing extended backwards&lt;br /&gt;
compatibility), so it’s a good rule of thumb to keep it in sync with a&lt;br /&gt;
conservative but still active channel that you trust. If you find a &lt;em&gt;killer&lt;/em&gt;&lt;br /&gt;
feature that you absolutely need in production, you should be aware of the&lt;br /&gt;
responsibilities coming with living in the bleeding-edge. For example, is the&lt;br /&gt;
upstream author responsive to bug reports? Do I have the capability to fix bugs&lt;br /&gt;
if push comes to shove?  Notice that, although ugly and cumbersome, there are&lt;br /&gt;
mechanisms to get conditional compilation based on the dependency version being&lt;br /&gt;
present while building. In Haskell this is done with &lt;a href=&quot;http://projects.haskell.org/cpphs&quot;&gt;CPP macros&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While thinking about this, it’s also a good moment to consider any security&lt;br /&gt;
implications. Can you afford the risks of the bleeding-edge? Perhaps your&lt;br /&gt;
application is a prototype, but are you sure it’ll remain one? What would need&lt;br /&gt;
to be done if it goes into production?&lt;/p&gt;

&lt;h2 id=&quot;known-working-sets&quot;&gt;Known Working Sets&lt;/h2&gt;

&lt;p&gt;Identifying individual channels for each package doesn’t guarantee they&lt;br /&gt;
will work together. What you need is a &lt;em&gt;distribution&lt;/em&gt; of packages with&lt;br /&gt;
versions that are frequently tested together for compatibility. These&lt;br /&gt;
&lt;em&gt;distributions&lt;/em&gt; usually have their own release channels as well.&lt;/p&gt;

&lt;p&gt;Theoretically, you could pick and choose different channels for each&lt;br /&gt;
package, and although this approach may work for projects with few&lt;br /&gt;
dependencies, in practice this quickly spirals out of control as the&lt;br /&gt;
number dependencies grows. If you avoid running into &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_hell&quot;&gt;dependency hell&lt;/a&gt;, the&lt;br /&gt;
combination of versions can make your build so unique that any potential bugs&lt;br /&gt;
you find may be irrelevant or hard to reproduce for the rest of the community.&lt;br /&gt;
By sticking to a trusted &lt;em&gt;distribution&lt;/em&gt; you take advantage of more people&lt;br /&gt;
looking for bugs in the same build you are working or if you discover the bugs&lt;br /&gt;
yourself you’ll get better support if your working set of dependencies is a&lt;br /&gt;
common one. This could be considered a weaker version of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Linus&#39;s_Law&quot;&gt;Linus’s&lt;br /&gt;
Law&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When choosing a &lt;em&gt;distribution&lt;/em&gt; it’s often helpful to distinguish 2 rough&lt;br /&gt;
categories: language runtime specific but system agnostic, and system specific&lt;br /&gt;
but language runtime agnostic&lt;sup id=&quot;fnref:b&quot;&gt;&lt;a href=&quot;#fn:b&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;For example, in Haskell, &lt;a href=&quot;http://www.stackage.org/lts&quot;&gt;Stackage LTS&lt;/a&gt;, or even the &lt;a href=&quot;https://www.haskell.org/platform/&quot;&gt;Haskell Platform&lt;/a&gt;,&lt;br /&gt;
can be considered examples of the first kind. No matter what OS or&lt;br /&gt;
hardware architecture you are on (provided GHC supports it), if you pick&lt;br /&gt;
the minimum versions from any of those sets, you can be pretty&lt;br /&gt;
confident that there won’t be compatibility issues. This type of&lt;br /&gt;
distributions work very well when your whole codebase is written for the&lt;br /&gt;
same language runtime. However, when the number of dependencies not&lt;br /&gt;
included in the distribution grows (for example, dependencies coming from&lt;br /&gt;
a different language runtime), your chances of running into problems grows,&lt;br /&gt;
too.&lt;/p&gt;

&lt;p&gt;The other kind of &lt;em&gt;distributions&lt;/em&gt; are the ones providing full system&lt;br /&gt;
integration for a given hardware architecture, with kernel and userspace&lt;br /&gt;
applications being released together. Here I have in mind the typical&lt;br /&gt;
Linux distributions and the BSDs&lt;sup id=&quot;fnref:c&quot;&gt;&lt;a href=&quot;#fn:c&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;System distributions provide the strongest guarantees that all moving&lt;br /&gt;
parts work together, specially if you get your package included in the&lt;br /&gt;
distribution. But doing so can be quite hard, you’ll have to make sure your&lt;br /&gt;
packages adheres to all the distributions policies, which usually are&lt;br /&gt;
quite strict.&lt;/p&gt;

&lt;p&gt;That’s why integrating your code into an system distribution can sometimes&lt;br /&gt;
add non-trivial overhead. Also, focusing on just one OS distribution can&lt;br /&gt;
reduce drastically the users you can target. This is not an issue for push&lt;br /&gt;
based deployments though.&lt;/p&gt;

&lt;p&gt;Even if you don’t use system distributions directly, you can still extract&lt;br /&gt;
a good known working set from the versions they selected.  You have to&lt;br /&gt;
keep an eye on any patches the packagers may have introduced that are not&lt;br /&gt;
included upstream. If those changes are not distribution specific, they&lt;br /&gt;
are usually propagated upstream, but sometimes for whatever reason,&lt;br /&gt;
upstream authors don’t accept them.&lt;/p&gt;

&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing thoughts&lt;/h2&gt;

&lt;p&gt;For the lower bounds of pull-based Haskell packages, I usually follow the&lt;br /&gt;
Debian stable channel which usually has oldest set of versions still being&lt;br /&gt;
maintained.&lt;/p&gt;

&lt;p&gt;For push based deployments, a very popular system distribution within the&lt;br /&gt;
Haskell community is &lt;a href=&quot;https://nixos.org/&quot;&gt;NixOS&lt;/a&gt;. Aside of the many advantages the &lt;a href=&quot;https://nixos.org/nix/&quot;&gt;Nix&lt;/a&gt;&lt;br /&gt;
package manager over conventional managers, from a curation perspective,&lt;br /&gt;
the &lt;a href=&quot;https://nixos.org/&quot;&gt;NixOS&lt;/a&gt; community is extremely responsive and provides a very smooth&lt;br /&gt;
barrier of entry for new Haskell packages&lt;sup id=&quot;fnref:d&quot;&gt;&lt;a href=&quot;#fn:d&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;It’s also worth mentioning that the latest upstream versions of every&lt;br /&gt;
dependencies can be considered a virtual quasi-distribution. Although this&lt;br /&gt;
target obviously moves very fast, it might not be as chaotic as you might&lt;br /&gt;
expect. Most upstream developers give priority to the latest version, so&lt;br /&gt;
they usually make sure their software works well with the latest versions&lt;br /&gt;
of other dependencies. This is not a bad choice for experimental and&lt;br /&gt;
prototype projects, and even if you are relying exclusively on pinned&lt;br /&gt;
versions, it’s always useful to test against the latest dependencies as a&lt;br /&gt;
way of getting a heads up on what needs to be done to keep your code&lt;br /&gt;
up-to-date.&lt;/p&gt;

&lt;p&gt;I deliberately omitted writing about new projects like &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; or &lt;a href=&quot;https://developer.ubuntu.com/en/snappy/&quot;&gt;Snappy&lt;br /&gt;
Ubuntu&lt;/a&gt; that claim to solve many all our deployment issues with container&lt;br /&gt;
superpowers. I do believe container based deployments, both for server and&lt;br /&gt;
for end users, are the right trend but I’m still, as of today, not sold on&lt;br /&gt;
using Docker for production. But that’s a story for another day.&lt;/p&gt;

&lt;p&gt;I also don’t want to get into the topic of upper version bounds because&lt;br /&gt;
it’s a whole different debate, and there are many valid arguments pro and&lt;br /&gt;
against. I personally lean towards not putting any restrictions because it&lt;br /&gt;
makes upgrading new packages an easy process, even at the cost of having&lt;br /&gt;
some users getting broken builds when new dependencies come out. This&lt;br /&gt;
shouldn’t be a problem for production systems because I’m assuming prudent&lt;br /&gt;
users should be using pinned versions and building their packages before&lt;br /&gt;
deployment. However if for some reason, your package is broken and you&lt;br /&gt;
know you can’t fix it soon enough, I’d say it’s OK to make a quick release&lt;br /&gt;
with upper version bounds if you already know it will break. I know there&lt;br /&gt;
are many counterarguments to my position, like for example, when you want&lt;br /&gt;
to make sure a package released today will be buildable in 20 years at&lt;br /&gt;
that particular version. I’d mark that old version as deprecated and&lt;br /&gt;
forget about it, but that’s sacrilege for some. In the end this is all&lt;br /&gt;
&lt;a href=&quot;https://en.wiktionary.org/wiki/bikeshedding&quot;&gt;bikeshedding&lt;/a&gt; to me, so even if I’d rather have no upper limits, I don’t&lt;br /&gt;
think it’s a big deal having to handle them.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:e&quot;&gt;
      &lt;p&gt;Or wherever you build it, it should be equivalent to building it on the target system. &lt;a href=&quot;#fnref:e&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:f&quot;&gt;
      &lt;p&gt;You could use &lt;code class=&quot;highlighter-rouge&quot;&gt;cabal freeze&lt;/code&gt; for quick and dirty pinning, but don’t recommend it when strict control of versions is desired. &lt;a href=&quot;#fnref:f&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:a&quot;&gt;
      &lt;p&gt;In Wheezy GHC-7.4.3, is still officially maintained in extended support if you really want to go back. &lt;a href=&quot;#fnref:a&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:b&quot;&gt;
      &lt;p&gt;A particular underrated package management system that is both language and OS portable is &lt;a href=&quot;https://www.pkgsrc.org/&quot;&gt;pkgsrc&lt;/a&gt;. Unfortunately, although Haskell curation is improving, it’s still far from other distributions. &lt;a href=&quot;#fnref:b&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:c&quot;&gt;
      &lt;p&gt;You could stretch the concept to include commercial app stores, or even runtime environments such as GNOME or frameworks like RxJS. &lt;a href=&quot;#fnref:c&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:d&quot;&gt;
      &lt;p&gt;yes, creating Nix expressions adds overhead, but believe me, it’s much more accessible than creating good deb or rpm source packages. &lt;a href=&quot;#fnref:d&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 12 Aug 2015 15:10:56 +0200</pubDate>
        <link>http://dannynavarro.net/2015/08/12/picking-lower-bounds-version-for-your-dependencies/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2015/08/12/picking-lower-bounds-version-for-your-dependencies/</guid>
        
        
        <category>haskell</category>
        
        <category>sysadmin</category>
        
      </item>
    
      <item>
        <title>Haskell role in FP paradigm shift</title>
        <description>&lt;p&gt;I was listening to &lt;a href=&quot;https://en.wikipedia.org/wiki/Bruce_Tate&quot;&gt;Bruce Tate&lt;/a&gt; in &lt;a href=&quot;http://mostlyerlang.com/&quot;&gt;Mostly Erlang&lt;/a&gt; podcast, when, around&lt;br /&gt;
the 57th minute of &lt;a href=&quot;http://mostlyerlang.com/2014/03/04/031-bruce-tate/&quot;&gt;the episode&lt;/a&gt;, the topic of the conversation&lt;br /&gt;
became the feasibility of &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;FP&lt;/a&gt; becoming mainstream. He explains that &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;FP&lt;/a&gt;&lt;br /&gt;
has not emerged yet, but it’s reluctantly about to do so, being the end of&lt;br /&gt;
Moore’s law the main driver as concurrent/parallel programming becomes&lt;br /&gt;
more critical.&lt;/p&gt;

&lt;p&gt;I agree with him about this trend, although I also think it’s easy to&lt;br /&gt;
overestimate the time it will take. I think it’s going to be very slow.&lt;/p&gt;

&lt;p&gt;Another interesting idea, he mentions is that within the &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;FP&lt;/a&gt; field, a clear&lt;br /&gt;
&lt;em&gt;winner&lt;/em&gt; may arise, as it happened with the C/C++, and all its descendants. The&lt;br /&gt;
four candidates he postulates are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.erlang.org/&quot;&gt;Erlang&lt;/a&gt;/&lt;a href=&quot;http://elixir-lang.org/&quot;&gt;Elixir&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://clojure.org/&quot;&gt;Clojure&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.scala-lang.org/&quot;&gt;Scala&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Javascript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;He dismisses &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; for not being approachable enough, similarly to when&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt; came out.&lt;/p&gt;

&lt;p&gt;I also think there’ll be a &lt;em&gt;winner&lt;/em&gt;, understanding for &lt;em&gt;winner&lt;/em&gt;, the&lt;br /&gt;
language most programmers and companies will use (i.e. Java would be a&lt;br /&gt;
&lt;em&gt;winner&lt;/em&gt; now). But I don’t see being a  &lt;em&gt;winner&lt;/em&gt; language, in this sense,&lt;br /&gt;
so relevant. To me, what’s really important is to see how prominent is&lt;br /&gt;
going to be the software written in that language, and how much of current&lt;br /&gt;
business will be run in code written in such language. A language could be&lt;br /&gt;
considered not mainstream by programmers and companies, but there may be&lt;br /&gt;
several critical widespread software that wouldn’t be possible without it.&lt;br /&gt;
For example, I see this trend going on with &lt;a href=&quot;http://www.erlang.org/&quot;&gt;Erlang&lt;/a&gt; being used in&lt;br /&gt;
critical &lt;a href=&quot;https://en.wikipedia.org/wiki/Instant_messaging&quot;&gt;IM&lt;/a&gt; services, distributed databases, message queuing systems,&lt;br /&gt;
etc. Current shops with expertise in &lt;a href=&quot;http://www.erlang.org/&quot;&gt;Erlang&lt;/a&gt;, even if not mainstream,&lt;br /&gt;
have a clear competitive advantage when writing scalable systems.&lt;/p&gt;

&lt;p&gt;In this sense, I think &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; may never be a &lt;em&gt;winner&lt;/em&gt;, but the question&lt;br /&gt;
is still open about how crucial will it be in the future. What will be the&lt;br /&gt;
business perspectives for the few companies proficient in &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;? Who&lt;br /&gt;
cares if there are few proficient &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; programmers as long as there&lt;br /&gt;
is a pool of &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; programmers to hire (which currently it seems there&lt;br /&gt;
is) and taking into account the strong hint that if someone is proficient&lt;br /&gt;
&lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; she has already very high chances of being a very productive&lt;br /&gt;
programmer?&lt;/p&gt;

&lt;p&gt;I guess this &lt;a href=&quot;http://paulgraham.com/avg.html&quot;&gt;same argument&lt;/a&gt; was the same used with &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, but now&lt;br /&gt;
there are some differences. &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt; idioms are, inherently, very&lt;br /&gt;
heterogeneous, whereas &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;, in spite of not having the equivalent of&lt;br /&gt;
being &lt;a href=&quot;http://blog.startifact.com/posts/older/what-is-pythonic.html&quot;&gt;Pythonic&lt;/a&gt;, is much more understandable among programmers working in&lt;br /&gt;
different projects. Secondly, there are certain&lt;br /&gt;
parallelization/concurrency problems that are very hard to get them right&lt;br /&gt;
with traditional languages, for example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_transactional_memory&quot;&gt;STM&lt;/a&gt;. I’m not an expert in&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt; but I guess it lacked the killer feature that make using it a need,&lt;br /&gt;
more than just a nice advantage.&lt;/p&gt;

&lt;p&gt;In conclusion, my opinion is that &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; has a very good chance of&lt;br /&gt;
becoming very relevant even if it doesn’t become the &lt;a href=&quot;https://en.wikipedia.org/wiki/Functional_programming&quot;&gt;FP&lt;/a&gt; language&lt;br /&gt;
&lt;em&gt;winner&lt;/em&gt;. I see its &lt;a href=&quot;https://en.wikipedia.org/wiki/Purely_functional&quot;&gt;purity&lt;/a&gt; and side-effect management as enablers of&lt;br /&gt;
killer features in the area of concurrent/parallel programming. Somehow,&lt;br /&gt;
the vibrancy of the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; community these days, reminds me of the&lt;br /&gt;
[Python] community before Google made it popular. Will all&lt;br /&gt;
this be enough to make &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; relevant? I guess time will tell.&lt;/p&gt;

</description>
        <pubDate>Tue, 08 Apr 2014 13:44:28 +0200</pubDate>
        <link>http://dannynavarro.net/2014/04/08/haskell-role-in-fp-paradigm-shift/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2014/04/08/haskell-role-in-fp-paradigm-shift/</guid>
        
        
        <category>haskell</category>
        
      </item>
    
      <item>
        <title>Podcast tribute</title>
        <description>&lt;p&gt;These days, with the pervasiveness of the Internet, an impressive wave of&lt;br /&gt;
new spoken audio content is making steadily its way into the mainstream.&lt;br /&gt;
I’ve always been a big fan of spoken radio, but now I find myself&lt;br /&gt;
listening only to independent &lt;a href=&quot;https://en.wikipedia.org/wiki/Podcast&quot;&gt;podcasts&lt;/a&gt;, mostly hosted by&lt;br /&gt;
amateurs, who are able to provide fresh and genuine content in a medium&lt;br /&gt;
where innovation has been stagnant for many years.&lt;/p&gt;

&lt;p&gt;The least I can do for all the countless hours of entertainment they are&lt;br /&gt;
giving me is to publicly express my admiration for them.&lt;/p&gt;

&lt;h4 id=&quot;hardcore-historyhttpwwwdancarlincomdispphphh&quot;&gt;&lt;a href=&quot;http://www.dancarlin.com/disp.php/hh&quot;&gt;Hardcore History&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;When a new episode of this podcast comes out I try to wrap up everything&lt;br /&gt;
I’m doing and take a hiking route with my dog long enough to listen to the&lt;br /&gt;
new episode uninterrupted. I think what makes &lt;a href=&quot;https://en.wikipedia.org/wiki/Dan_Carlin&quot;&gt;Dan Carlin&lt;/a&gt; outstanding as&lt;br /&gt;
a narrator is his great ability to immerse the listener in the situation&lt;br /&gt;
of the era and to describe how it felt to be in the shoes of the people&lt;br /&gt;
living through it. All in all, after listening to several episodes, I came&lt;br /&gt;
to realize we are not so different from our ancestors, and in most cases,&lt;br /&gt;
no matter how horrible the consequences of some actions were, we’d&lt;br /&gt;
probably have done the same.&lt;/p&gt;

&lt;h4 id=&quot;histocast-spanishhttpwwwhistocastcom&quot;&gt;&lt;a href=&quot;http://www.histocast.com&quot;&gt;HistoCast (Spanish)&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This history podcast is carried in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tertulia&quot;&gt;&lt;em&gt;tertulia&lt;/em&gt;&lt;/a&gt; format by a panel of&lt;br /&gt;
history aficionados. The general tone is informal but at the same time&lt;br /&gt;
it’s quite rigorous regarding the information they provide and throughout&lt;br /&gt;
in their analysis. The anecdotes they manage to find are priceless.&lt;/p&gt;

&lt;h4 id=&quot;colectivo-burbuja-spanishhttpwwwcolectivoburbujaorg&quot;&gt;&lt;a href=&quot;http://www.colectivoburbuja.org/&quot;&gt;Colectivo Burbuja (Spanish)&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;When living in a country like &lt;a href=&quot;http://www.heritage.org/index/country/spain&quot;&gt;Spain&lt;/a&gt;, with a government filled with&lt;br /&gt;
corrupted crooks who control practically all traditional media outlets,&lt;br /&gt;
independent podcasts like this one are really appreciated. It mostly&lt;br /&gt;
consists of debates with speakers of diverse ideologies analyzing current&lt;br /&gt;
news, mainly economic. It really helps understand what is really going on&lt;br /&gt;
in this country, full of strange contradictions.&lt;/p&gt;

&lt;h4 id=&quot;security-nowhttpswwwgrccomsecuritynowhtm&quot;&gt;&lt;a href=&quot;https://www.grc.com/securitynow.htm&quot;&gt;Security Now&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Steve_Gibson_(computer_programmer)&quot;&gt;Steve Gibson&lt;/a&gt; could be accused of being an expert in &lt;a href=&quot;https://en.wikipedia.org/wiki/Public_relations&quot;&gt;PR&lt;/a&gt; more than an&lt;br /&gt;
expert in information security but, in spite of this, I find hard to deny&lt;br /&gt;
his didactic ability to introduce the listener to different security&lt;br /&gt;
concepts and to summarize the most important security events of the week.&lt;/p&gt;

&lt;h4 id=&quot;linux-outlawshttpsixgunorglinuxoutlaws&quot;&gt;&lt;a href=&quot;http://sixgun.org/linuxoutlaws&quot;&gt;Linux Outlaws&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;By the title one would expect a highly technical podcast, but more than&lt;br /&gt;
a podcast about the Linux world, this is about using Linux as a excuse for&lt;br /&gt;
numerous ranting, cynical comments and nerdy jokes, which I find really&lt;br /&gt;
funny.&lt;/p&gt;

&lt;h4 id=&quot;byzantine-rulershttp12byzantinerulerscom-and-norman-centurieshttpnormancenturiescom&quot;&gt;&lt;a href=&quot;http://12byzantinerulers.com/&quot;&gt;12 Byzantine Rulers&lt;/a&gt; and &lt;a href=&quot;http://normancenturies.com/&quot;&gt;Norman Centuries&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Even if they are considered podcasts, they feel more like history&lt;br /&gt;
audiobooks. &lt;a href=&quot;https://en.wikipedia.org/wiki/Lars_brownworth&quot;&gt;Lars Brownworth&lt;/a&gt; fabulously narrates relatively unknown&lt;br /&gt;
amazing epochs which were highly influential but didn’t get the historical&lt;br /&gt;
popularity they deserved.&lt;/p&gt;

&lt;h4 id=&quot;the-joe-rogan-experiencehttppodcastsjoerogannet&quot;&gt;&lt;a href=&quot;http://podcasts.joerogan.net/&quot;&gt;The Joe Rogan Experience&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Joe_Rogan&quot;&gt;Joe Rogan&lt;/a&gt; interviews in a funny and informal tone diverse personalities.&lt;br /&gt;
I view these discussions as examples of honest civilized conversations&lt;br /&gt;
between individuals with very different backgrounds. I also found very&lt;br /&gt;
interesting podcasters through this podcast.&lt;/p&gt;

&lt;h4 id=&quot;the-haskellcasthttpwwwhaskellcastcom&quot;&gt;&lt;a href=&quot;http://www.haskellcast.com/&quot;&gt;The HaskellCast&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Because these days I’m coding full-time in &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt;, in this podcast, I&lt;br /&gt;
really appreciate the interviews to prominent figures in the community.&lt;br /&gt;
What I like the most about listening to them instead of just reading what&lt;br /&gt;
they write, is that somehow, by hearing them explain what they do, it’s&lt;br /&gt;
easier to grasp the train of thought that led them to do what they did.&lt;/p&gt;

&lt;h4 id=&quot;revolutionshttpwwwrevolutionspodcastcom&quot;&gt;&lt;a href=&quot;http://www.revolutionspodcast.com/&quot;&gt;Revolutions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This history podcast is very informationally dense but fun to listen to&lt;br /&gt;
nevertheless. &lt;a href=&quot;https://en.wikipedia.org/wiki/Mike_Duncan_(podcaster)&quot;&gt;Mike Duncan&lt;/a&gt; does a great job explaining the high&lt;br /&gt;
complexity of events that led to big changes in history. He’s also the&lt;br /&gt;
author of &lt;a href=&quot;http://thehistoryofrome.typepad.com/&quot;&gt;History of Rome&lt;/a&gt; which I still haven’t gone through but hope to&lt;br /&gt;
start doing it that at some point.&lt;/p&gt;

&lt;h4 id=&quot;pasajes-de-la-historia-spanishhttppasajesdelahistoriaueuocom&quot;&gt;&lt;a href=&quot;http://pasajesdelahistoria.ueuo.com/&quot;&gt;Pasajes de la Historia (Spanish)&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This is one of the few podcasts I listen that it’s taken from traditional&lt;br /&gt;
media. Unfortunately, &lt;a href=&quot;https://es.wikipedia.org/wiki/Juan_Antonio_Cebri%C3%A1n&quot;&gt;Juan Antonio Cebrián&lt;/a&gt; passed away prematurely but&lt;br /&gt;
left an incredible legacy in the form of tales based on historical&lt;br /&gt;
figures.&lt;/p&gt;

&lt;h4 id=&quot;lets-talk-bitcoinhttpletstalkbitcoincom&quot;&gt;&lt;a href=&quot;http://letstalkbitcoin.com/&quot;&gt;Let’s talk Bitcoin&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This is also a podcast I follow for professional reasons. If I had to&lt;br /&gt;
choose a single &lt;a href=&quot;https://bitcoin.org/&quot;&gt;Bitcoin&lt;/a&gt; podcast this would be the one.&lt;/p&gt;

&lt;!---
vim: tw=74 spell
--&gt;
</description>
        <pubDate>Wed, 26 Mar 2014 20:53:58 +0100</pubDate>
        <link>http://dannynavarro.net/2014/03/26/podcast-tribute/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2014/03/26/podcast-tribute/</guid>
        
        
        <category>podcast</category>
        
        <category>fun</category>
        
        <category>history</category>
        
      </item>
    
      <item>
        <title>An opinionated importing style for Haskell</title>
        <description>&lt;p&gt;Large part of &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; code is just about imports. In many programming&lt;br /&gt;
languages there is no ambiguity left about how to import, but &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt;&lt;br /&gt;
leaves some room for personal style in this regard. There are some&lt;br /&gt;
recommendations out there about importing style, but most is left to&lt;br /&gt;
common sense. Your own judgment, once you are comfortable with &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt;,&lt;br /&gt;
should be perfectly fine, but newcomers who care about style consistency&lt;br /&gt;
might feel a bit lost when writing the import list for their own packages&lt;br /&gt;
&lt;sup id=&quot;fnref:d&quot;&gt;&lt;a href=&quot;#fn:d&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, specially since there are many slightly different styles in the wild&lt;br /&gt;
for &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; imports. In this post, I’ll try to explain the rationale of&lt;br /&gt;
the style I follow.&lt;/p&gt;

&lt;p&gt;One basic principle I’ll be following for all my criteria is that, like I&lt;br /&gt;
guess most programmers, code style is about reading code, not writing it.&lt;br /&gt;
When writing, you can make the assumption that someone editing the code&lt;br /&gt;
has access to editing tools, whereas this assumption doesn’t hold so&lt;br /&gt;
easily for the readers of your code.&lt;/p&gt;

&lt;h2 id=&quot;explicit-imports&quot;&gt;Explicit imports&lt;/h2&gt;

&lt;p&gt;Anyone reading the &lt;a href=&quot;http://python.org&quot;&gt;Python&lt;/a&gt; &lt;a href=&quot;http://docs.python.org/3/tutorial/index.html&quot;&gt;official tutorial&lt;/a&gt;&lt;br /&gt;
for the first time has to read through this when reaching the section&lt;br /&gt;
about &lt;a href=&quot;http://docs.python.org/3/tutorial/modules.html#modules&quot;&gt;modules&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There is even a variant to import all names that a module defines:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
from fibo import *
fib(500)
&lt;/code&gt;&lt;br /&gt;
This imports all names except those beginning with an underscore (&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;). In&lt;br /&gt;
most cases Python programmers do not use this facility since it introduces an&lt;br /&gt;
unknown set of names into the interpreter, possibly hiding some things you&lt;br /&gt;
have already defined.&lt;/p&gt;

  &lt;p&gt;Note that in general &lt;strong&gt;the practice of importing &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; from a module or package is&lt;br /&gt;
frowned upon&lt;/strong&gt;, since it often causes poorly readable code. However, it is okay&lt;br /&gt;
to use it to save typing in interactive sessions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This means that anything but a small &lt;em&gt;built-in&lt;/em&gt; language core, which it&lt;br /&gt;
can be easily memorized, has to be explicitly exported to be in scope.&lt;br /&gt;
This is great for newcomers reading any Python code, you are always aware,&lt;br /&gt;
with no extra tools, where everything is coming from.&lt;/p&gt;

&lt;p&gt;Considering that &lt;a href=&quot;http://python.org&quot;&gt;Python&lt;/a&gt; is my programming language I learned first, you&lt;br /&gt;
can understand why I get a bit annoyed when I’m reading other language I’m&lt;br /&gt;
not so familiar with, and names just pop up in scope without knowing where&lt;br /&gt;
they come from. And no, I don’t want to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Ctags&quot;&gt;ctags&lt;/a&gt; or a full blown IDE&lt;br /&gt;
every time I’m reading casually some code on the GitHub.&lt;/p&gt;

&lt;p&gt;So then, why &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt;, a language with such a great reputation for being&lt;br /&gt;
so well designed, doesn’t follow these &lt;a href=&quot;http://python.org&quot;&gt;Python&lt;/a&gt; principles, which look so&lt;br /&gt;
advantageously obvious? To be fair with &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt;, we have to understand&lt;br /&gt;
that the class system in &lt;a href=&quot;http://python.org&quot;&gt;Python&lt;/a&gt; is frequently &lt;em&gt;(ab)&lt;/em&gt;used&lt;sup id=&quot;fnref:a&quot;&gt;&lt;a href=&quot;#fn:a&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; just for&lt;br /&gt;
organizational purposes. &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt;, by being a &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_functional_language&quot;&gt;pure functional&lt;br /&gt;
programming language&lt;/a&gt;, doesn’t add all the cruft of &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_(computer_programming)&quot;&gt;OOP classes&lt;/a&gt; just to&lt;br /&gt;
deal with this issue. Instead, it uses a very limited module system which&lt;br /&gt;
could be argued is a weakness of the language, but I believe it fits&lt;br /&gt;
nicely with the unofficial &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; slogan of &lt;a href=&quot;http://www.reddit.com/r/programming/comments/77z8h/avoid_success_at_all_costs_the_unofficial_slogan/&quot;&gt;&lt;em&gt;avoid success at all&lt;br /&gt;
costs&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From my understanding, this means that if there is not an optimal solution&lt;br /&gt;
for a core language feature, it’s preferable to keep the bare minimum&lt;br /&gt;
everyone agrees on and don’t try to impose a half-baked solution that will&lt;br /&gt;
have to be maintained forever for legacy reasons. Taking this into&lt;br /&gt;
account, I’d rather have a dumb module system easy to understand, than&lt;br /&gt;
having to deal forever with the complexity of historical design&lt;br /&gt;
accidents.&lt;sup id=&quot;fnref:b&quot;&gt;&lt;a href=&quot;#fn:b&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;So in &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; we have to bite the bullet and accept that the imports&lt;br /&gt;
lists are going to be quite complex, and making absolutely every import&lt;br /&gt;
explicit like in &lt;a href=&quot;http://python.org&quot;&gt;Python&lt;/a&gt; would be too cumbersome on the programmer who is&lt;br /&gt;
coding, so we have to reach some kind of trade-off between explicitness&lt;br /&gt;
for the reader vs convenience for the writer.&lt;/p&gt;

&lt;h3 id=&quot;internal-imports&quot;&gt;Internal imports&lt;/h3&gt;

&lt;p&gt;A popular style recommendation like &lt;a href=&quot;https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#imports&quot;&gt;the one from Johan Tibell&lt;/a&gt; is to import explicitly everything outside the package, and&lt;br /&gt;
make internal imports implicit.&lt;/p&gt;

&lt;p&gt;I consider Tibell’s way a good rule to follow for most projects. It’s a&lt;br /&gt;
good compromise because when reading a module from a givne package, it’s&lt;br /&gt;
reasonable to assume the rest of modules of such package are usually nearby.&lt;/p&gt;

&lt;p&gt;The other popular way &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#ExportsandImports&quot;&gt;recommended in GHC&lt;/a&gt; is to make&lt;br /&gt;
everything implicit. Breaking Tibell’s rule in the case of GHC may be&lt;br /&gt;
understandable because in a project as large as &lt;a href=&quot;https://www.haskell.org/ghc&quot;&gt;GHC&lt;/a&gt;, the import lists&lt;br /&gt;
would tend to be quite complex. I’d also assume anyone trying to hack on&lt;br /&gt;
&lt;a href=&quot;https://www.haskell.org/ghc&quot;&gt;GHC&lt;/a&gt; is above beginner’s level and should be familiar with internals of the&lt;br /&gt;
project. But for most projects, I think &lt;a href=&quot;https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#imports&quot;&gt;Tibell’s&lt;br /&gt;
recommendation&lt;/a&gt; is a good default.&lt;/p&gt;

&lt;p&gt;It could be argued that if there are many internal modules being imported&lt;br /&gt;
in the same module, it could become difficult to follow from which module&lt;br /&gt;
comes each name. It’s true that this sometimes happens, but most of the&lt;br /&gt;
time I’d attribute to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_smell&quot;&gt;smell&lt;/a&gt;. When this happens, I’d look&lt;br /&gt;
for the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Are modules not modular enough?&lt;/em&gt; For good modularity the&lt;br /&gt;
communication between them should be as minimal as possible. Perhaps&lt;br /&gt;
the code needs to be rearranged in entirely different modules to&lt;br /&gt;
allow better separation of concerns.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Is the package too large?&lt;/em&gt; Maybe it’s time to separate the packages in&lt;br /&gt;
more subpackages.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Are you always importing a group of modules that somehow can be&lt;br /&gt;
logically grouped together?&lt;/em&gt; All these modules could be consolidated in&lt;br /&gt;
a single module that just re-exports everything for the module group.&lt;br /&gt;
This, in fact, a very used pattern in &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; for code organization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only exception to external explicit importing is &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt;, which is&lt;br /&gt;
almost always implicitly imported. &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; is the closest you get to&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;built-ins&lt;/code&gt; in &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Whenever I have some name clash with a &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; name I don’t hesitate to&lt;br /&gt;
hide the &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; version if the context makes it clear that the imported&lt;br /&gt;
name is not the same as the one in &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt;. For example, I’d hide the&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude.span&lt;/code&gt;, if I’m not using it and if the imported &lt;code class=&quot;highlighter-rouge&quot;&gt;span&lt;/code&gt; deals, for&lt;br /&gt;
example, with an span HTML element. But I wouldn’t hide&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude.writeFile&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.Bytestring.writeFile&lt;/code&gt; because it’d be&lt;br /&gt;
misleading. In case of not hiding, I’d use a qualified import, but I’ll&lt;br /&gt;
comment more about them below.&lt;/p&gt;

&lt;p&gt;Some people also give the &lt;code class=&quot;highlighter-rouge&quot;&gt;built-in&lt;/code&gt; status to other very frequently used&lt;br /&gt;
modules such as &lt;code class=&quot;highlighter-rouge&quot;&gt;Control.Monad&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.Monoid&lt;/code&gt; in the &lt;a href=&quot;http://hackage.haskell.org/package/base&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt;&lt;br /&gt;
package&lt;/a&gt;. Even admitting that anyone with some experience with&lt;br /&gt;
&lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; wouldn’t have any trouble with these imports being implicit, I&lt;br /&gt;
still import them explicitly. I consider that, for experienced programmers&lt;br /&gt;
who are not familiar with Haskell, the names in &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; are enough to&lt;br /&gt;
keep in mind, so, in my opinion, asking to memorize more modules  rises&lt;br /&gt;
too much the barrier of entry. I suffered this myself when learning&lt;br /&gt;
&lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; for the first time, so I swore to myself I wouldn’t do it in the&lt;br /&gt;
future.&lt;/p&gt;

&lt;h3 id=&quot;constructors&quot;&gt;Constructors&lt;/h3&gt;

&lt;p&gt;The usual convention for importing type constructors is to import them&lt;br /&gt;
implicitly using the &lt;code class=&quot;highlighter-rouge&quot;&gt;(..)&lt;/code&gt; notation, but I don’t follow this convention&lt;br /&gt;
because if many type constructors are brought into scope, we have the same&lt;br /&gt;
problem as with the scope of functions.&lt;/p&gt;

&lt;p&gt;I only use &lt;code class=&quot;highlighter-rouge&quot;&gt;A(..)&lt;/code&gt; if there is only a constructor for type &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and it’s&lt;br /&gt;
named &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; as well, which is the usual convention. If that’s not the case I&lt;br /&gt;
also import the single constructor explicitly.&lt;sup id=&quot;fnref:e&quot;&gt;&lt;a href=&quot;#fn:e&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h3 id=&quot;qualified-imports&quot;&gt;Qualified imports&lt;/h3&gt;

&lt;p&gt;They are frequently cited as the solution to module organization. However&lt;br /&gt;
I’m uneasy about them and try to use them the least I can.&lt;/p&gt;

&lt;h4 id=&quot;maintainability&quot;&gt;Maintainability&lt;/h4&gt;

&lt;p&gt;When there is a very long list of imports it’s often argued that it’s&lt;br /&gt;
better for maintainability to just use a single qualified import,&lt;br /&gt;
otherwise it’s too much work to change the list of imports anytime there&lt;br /&gt;
is an API change in an external module. But I think it’s the other way&lt;br /&gt;
around, maintaining that list makes sure you are using the API properly,&lt;br /&gt;
and if you get an error when upgrading the API, you are more likely to get&lt;br /&gt;
an import error which can be easily spotted. On the other hand, with a&lt;br /&gt;
qualified import, the module being upgraded can inadvertently introduce&lt;br /&gt;
names in scope provoking clash errors which may be harder to debug.&lt;/p&gt;

&lt;p&gt;It’s true that it’s a bit extra effort to be constantly maintaining a long&lt;br /&gt;
list of imports, but with a decent code editor it shouldn’t be too much of&lt;br /&gt;
a problem. I usually toggle between implicit and explicit imports while&lt;br /&gt;
finding out a good solution to some code I’m writing, when I’m satisfied I&lt;br /&gt;
make sure everything is exported explicitly again.&lt;/p&gt;

&lt;h4 id=&quot;letter-soup&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Word_search&quot;&gt;Letter soup&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;It’s quite usual to find qualified imports with a capital letter like:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;import qualified Data.ByteString as B&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;import qualified
Data.ByteString as S&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;import qualified Data.ByteString.Lazy as B&lt;/code&gt; or&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;import Data.Binary as B&lt;/code&gt;… you get where I’m going.&lt;/p&gt;

&lt;p&gt;The problem with qualified names with just a few characters, it’s that the&lt;br /&gt;
chance of clashing is very high, so the same qualified import ends up with&lt;br /&gt;
different letters depending on the module, something I find confusing,&lt;br /&gt;
specially when you get used to associate a particular character to a&lt;br /&gt;
particular module. Aside of this, I don’t find aesthetically pleasing to&lt;br /&gt;
read all over the code single capital letters followed by some function,&lt;br /&gt;
but this may be just me.&lt;/p&gt;

&lt;p&gt;There are exceptions to this recommendation, of course, which I’ll explain&lt;br /&gt;
below.&lt;/p&gt;

&lt;h4 id=&quot;verbosity&quot;&gt;Verbosity&lt;/h4&gt;

&lt;p&gt;One obvious solution to the problem described below is to not use short&lt;br /&gt;
qualified names but full words like &lt;code class=&quot;highlighter-rouge&quot;&gt;ByteString&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Binary&lt;/code&gt;&lt;br /&gt;
instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Text&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;. But then, what happens when you&lt;br /&gt;
have a module using everywhere &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.ByteString&lt;/code&gt; and&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Data.ByteString.Lazy&lt;/code&gt;? Do you write prepend every function with&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ByteString&lt;/code&gt; an &lt;code class=&quot;highlighter-rouge&quot;&gt;ByteStringLazy&lt;/code&gt;? Common sense would tell us that this is&lt;br /&gt;
too verbose, specially for a language like &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; where terseness is&lt;br /&gt;
one of its most touted features. I’ll explain when to use long names for&lt;br /&gt;
qualified imports below.&lt;/p&gt;

&lt;h4 id=&quot;import-list-as-an-introduction&quot;&gt;Import list as an introduction&lt;/h4&gt;

&lt;p&gt;When I’m opening a module, I like going through the list of imports to&lt;br /&gt;
prepare my mind for the context of the module. When I find something like&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;import qualified Data.Binary as Binary&lt;/code&gt;, the first thing I think to&lt;br /&gt;
myself is: &lt;em&gt;is this module going use just one function from &lt;code class=&quot;highlighter-rouge&quot;&gt;Binary&lt;/code&gt; or is it&lt;br /&gt;
going to use many of them?&lt;/em&gt;. I know I can have a quick glance at the rest&lt;br /&gt;
of the module to get an idea, but this adds just more friction for cases&lt;br /&gt;
where, for example, I want to quickly navigate through all the modules of&lt;br /&gt;
a package in order to get quick overview.&lt;/p&gt;

&lt;p&gt;That’s why I prefer to have explicit lists, even when qualified imports&lt;br /&gt;
are being used. For such case, however, I acknowledge that I don’t always&lt;br /&gt;
follow my own advice. I consider them nice to have, not very important.&lt;/p&gt;

&lt;h4 id=&quot;when-qualified-imports-are-ok&quot;&gt;When qualified imports are OK&lt;/h4&gt;

&lt;p&gt;The first broad scenario has to do with &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt;. Is the module being&lt;br /&gt;
imported going to clash with several other functions from &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; that&lt;br /&gt;
I’ll also be using or are difficult to distinguish by context? If this is&lt;br /&gt;
the case then I’ll try to use a qualified import, specially when the&lt;br /&gt;
original author recommends it. The usual suspects in this list are imports&lt;br /&gt;
like &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.Foldable&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.Traversable&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;bytestring&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;B8&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;L8&lt;/code&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TIO&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TL&lt;/code&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;containers&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;),&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;pipes&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PP&lt;/code&gt;), etc. I try to follow the same letter convention&lt;br /&gt;
everywhere. But notice that if I know I won’t use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; version at&lt;br /&gt;
all and from the context it can be clearly distinguished that is not the&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt; function, then I’ll hide it as I explained above for the &lt;code class=&quot;highlighter-rouge&quot;&gt;span&lt;/code&gt;&lt;br /&gt;
example. It’s import to notice that for these packages, the types can be&lt;br /&gt;
usually imported unqualified without any issue.&lt;/p&gt;

&lt;p&gt;The second scenario is when 2 imported modules clash with the same names.&lt;br /&gt;
In this case I’d use qualified names for just the conflicting functions.&lt;br /&gt;
For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;Binary.decode&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Cereal.decode&lt;/code&gt;. If the modules are the&lt;br /&gt;
usual candidates for single letter qualified names like like &lt;code class=&quot;highlighter-rouge&quot;&gt;bytestring&lt;/code&gt;&lt;br /&gt;
and &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt; I’ll keep using the single letter, otherwise I’d use a long&lt;br /&gt;
name.&lt;/p&gt;

&lt;p&gt;There is one last case where using long qualified names would be OK with&lt;br /&gt;
me. For example, when the function uses a very vague name where it’s&lt;br /&gt;
difficult to guess what’s really about, it may be appropriate to prepend&lt;br /&gt;
it with the module name. For example, the &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt; functions from&lt;br /&gt;
the &lt;code class=&quot;highlighter-rouge&quot;&gt;State&lt;/code&gt; monad are much easier to identify when writing them as&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;State.get&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;State.put&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;order-of-imports&quot;&gt;Order of imports&lt;/h2&gt;

&lt;p&gt;Some criteria for ordering imports is important because it makes it&lt;br /&gt;
possible to predict in which order modules appear. If you get used to&lt;br /&gt;
the same pattern of appearance, you can quickly find what’s in the module&lt;br /&gt;
and what is not.&lt;/p&gt;

&lt;h3 id=&quot;modules&quot;&gt;Modules&lt;/h3&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#imports&quot;&gt;Tibell’s guide&lt;/a&gt; it’s recommended to group the&lt;br /&gt;
imports by standard library, third party software, and local package&lt;br /&gt;
imports. I follow this too, but, firstly, I distinguish in the standard&lt;br /&gt;
library the modules coming from &lt;a href=&quot;http://hackage.haskell.org/package/base&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://www.haskell.org/ghc&quot;&gt;GHC&lt;/a&gt; libraries and packages&lt;br /&gt;
belonging to the &lt;a href=&quot;http://www.haskell.org/platform&quot;&gt;Haskell Platform&lt;/a&gt;. Secondly, where Tibell recommends to&lt;br /&gt;
sort alphabetically between groups, I try to follow the rule of which&lt;br /&gt;
package is (or should be) most frequently used overall, and within each&lt;br /&gt;
package which module is most prominent. When this is not obvious then&lt;br /&gt;
alphabetical sorting should be used.&lt;/p&gt;

&lt;p&gt;Of course, there is no precise way to define which package is more&lt;br /&gt;
frequently used. I’d leave this entirely to your own personal experience&lt;br /&gt;
but you can get some idea by checking the &lt;a href=&quot;http://packdeps.haskellers.com&quot;&gt;reverse dependencies&lt;/a&gt; of a&lt;br /&gt;
package, or the downloads in &lt;a href=&quot;http://hackage.haskell.org&quot;&gt;Hackage&lt;/a&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;grep &amp;lt;module&amp;gt; | wc&lt;/code&gt; a bunch&lt;br /&gt;
popular packages.&lt;/p&gt;

&lt;p&gt;The main purpose of this rule is to try to make it easier to skim through&lt;br /&gt;
the most usual imports first and focus at the end on the rare module&lt;br /&gt;
exports. This is also important when trying to minimize dependencies, you&lt;br /&gt;
can quickly spot which ones you can try to drop.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Applicative&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Monoid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Foldable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here, I put &lt;code class=&quot;highlighter-rouge&quot;&gt;Applicative&lt;/code&gt; before &lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt; because even though, in practice,&lt;br /&gt;
it might be less used, my own judgement tells me it’s more general than a&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt;, so it &lt;em&gt;should&lt;/em&gt; be more frequent. Between the &lt;code class=&quot;highlighter-rouge&quot;&gt;Control&lt;/code&gt; and the&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; module names I choose to sort them alphabetically, I don’t know&lt;br /&gt;
which one is most usual. Whatever you decide, it’s always better to stick&lt;br /&gt;
with the same preference everywhere.&lt;/p&gt;

&lt;p&gt;Notice also that I don’t take into account the length of the export list&lt;br /&gt;
or how frequent are the functions appear in the module itself. That would,&lt;br /&gt;
perhaps, be valid criteria but they wouldn’t make the import list very&lt;br /&gt;
repeatable.&lt;/p&gt;

&lt;h3 id=&quot;types-and-functions&quot;&gt;Types and functions&lt;/h3&gt;

&lt;p&gt;I group first the &lt;code class=&quot;highlighter-rouge&quot;&gt;Types&lt;/code&gt; with their constructors; next, &lt;a href=&quot;http://www.haskell.org/haskellwiki/Infix_operator&quot;&gt;infix functions&lt;/a&gt;&lt;br /&gt;
and lastly, all other functions.&lt;/p&gt;

&lt;p&gt;When there is a mixture of qualified and unqualified imports for the same&lt;br /&gt;
import I still group them together, with the unqualified names going&lt;br /&gt;
first. I don’t like having the qualified imports and unqualified imports&lt;br /&gt;
grouped separately because usually I find myself moving back and forth&lt;br /&gt;
some functions between them.&lt;/p&gt;

&lt;p&gt;There is an exception here though. When the module being imported is&lt;br /&gt;
re-exporting names defined in other modules I then group them after the&lt;br /&gt;
ones which are defined directly in the imported module.&lt;/p&gt;

&lt;h2 id=&quot;formatting&quot;&gt;Formatting&lt;/h2&gt;

&lt;p&gt;I use multiple lines when the list of imports overpasses the specified&lt;br /&gt;
text width and a indentation of 2 spaces when happening.&lt;/p&gt;

&lt;p&gt;I also add spaces to module lists but not for constructors, just to give a&lt;br /&gt;
quick hint that they are constructors. For example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-|-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;… unless the constructors are multiline, which is not that frequent though:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A1&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A2&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;AN&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func1&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I know of editing tools to make vertical alignment very simple, but,&lt;br /&gt;
personally, I don’t find vertical alignment improving that much in&lt;br /&gt;
readability. The words in the same line tend to be too separated.&lt;/p&gt;

&lt;h2 id=&quot;canonical-example&quot;&gt;Canonical example&lt;/h2&gt;

&lt;p&gt;The import style followed by &lt;a href=&quot;http://haskell-distributed.github.io&quot;&gt;Cloud Haskell&lt;/a&gt; packages aligns quite well&lt;br /&gt;
with my particular style. This is a modified version taken from&lt;br /&gt;
&lt;a href=&quot;https://github.com/haskell-distributed/distributed-process/blob/master/src/Control/Distributed/Process/Node.hs#L16&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Control.Distributed.Process.Node&lt;/code&gt;&lt;/a&gt;: &lt;sup id=&quot;fnref:c&quot;&gt;&lt;a href=&quot;#fn:c&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;hiding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- &#39;base&#39; imports&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Category&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Applicative&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Concurrent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forkIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Foldable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forM_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Maybe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isJust&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isNothing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;catMaybes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Typeable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Typeable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Exception&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;throwIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;SomeException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;throwTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.IO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fixIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hPutStrLn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Mem.Weak&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deRefWeak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- imports from the rest of the Haskell Platform&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad.IO.Class&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MonadIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;liftIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- &#39;transformers&#39; package&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad.State.Strict&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MonadState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;StateT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;evalStateT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- these are likely to clash with local bindings&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad.State.Strict&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad.Reader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MonadReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ReaderT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runReaderT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.ByteString.Lazy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fromChunks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;partitionWithKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;filterWithKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foldlWithKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- these are likely to clash with other names&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Map&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fromList&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elems&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Set&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Binary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Network.Transport&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Transport&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EndPoint&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- Assuming there is only the &#39;Event&#39; constructor&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EventErrorCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TransportError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ConnectionId&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Connection&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newEndPoint&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closeEndPoint&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- This would re-exports in &#39;Network.transport&#39;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;EndPointAddress&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Reliability&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ReliableOrdered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- qualified because names are too vague&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Network.Transport&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NT&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receive&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I was keeping all these rules in my head until after a constructive&lt;br /&gt;
discussion with &lt;a href=&quot;http://ro-che.info&quot;&gt;Roman Cheplyaka&lt;/a&gt; about the topic, I decided to write them&lt;br /&gt;
down in a post that I could use as a reference for myself and for my&lt;br /&gt;
colleagues. But, by no means, I’m trying to claim my style is better than&lt;br /&gt;
any other, this is what I follow as of today, and will surely evolve as my&lt;br /&gt;
experience in &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; grows.&lt;/p&gt;

&lt;p&gt;If you just got into &lt;a href=&quot;http://haskell.org&quot;&gt;Haskell&lt;/a&gt; and find yourself trying to follow some&lt;br /&gt;
consistent importing style through your code, but lack the hands-on&lt;br /&gt;
experience to assess what’s best for you (and if you are control freak&lt;br /&gt;
like me), you might want to follow this blindly until you have more skin&lt;br /&gt;
in the game and can make a more confident decision of what style you&lt;br /&gt;
prefer to stick with. One advantage of this style is that, even if other&lt;br /&gt;
Haskell programmers don’t like it because of its extra editing work, it’s&lt;br /&gt;
still easily readable.&lt;/p&gt;

&lt;p&gt;But remember one thing, all this doesn’t matter if a project already&lt;br /&gt;
follows its own style. Consistency is always better for readability, even&lt;br /&gt;
if you don’t like the style. So always trust more your common sense than&lt;br /&gt;
any styling guide for which it’s impossible to define every scenario you&lt;br /&gt;
may encounter in real life.&lt;/p&gt;

&lt;!---
vim: textwidth=74
--&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:d&quot;&gt;
      &lt;p&gt;For code contributions it’s easy, just follow what the original author is already doing. &lt;a href=&quot;#fnref:d&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:a&quot;&gt;
      &lt;p&gt;This could be arguable considered the main use case for OOP in most languages. &lt;a href=&quot;#fnref:a&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:b&quot;&gt;
      &lt;p&gt;There is &lt;a href=&quot;http://plv.mpi-sws.org/backpack&quot;&gt;some research&lt;/a&gt; going on but still a long way to reach consensus. &lt;a href=&quot;#fnref:b&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:e&quot;&gt;
      &lt;p&gt;For exports I think it’s alright to always use &lt;code class=&quot;highlighter-rouge&quot;&gt;(..)&lt;/code&gt;, the constructors are in the same module. &lt;a href=&quot;#fnref:e&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:c&quot;&gt;
      &lt;p&gt;My modifications will surely break the code, this is just a sample demonstration. &lt;a href=&quot;#fnref:c&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 17 Mar 2014 21:17:15 +0100</pubDate>
        <link>http://dannynavarro.net/2014/03/17/an-opinionated-importing-style-for-haskell/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2014/03/17/an-opinionated-importing-style-for-haskell/</guid>
        
        
        <category>haskell</category>
        
      </item>
    
      <item>
        <title>Improving readability with the Maybe Foldable instance</title>
        <description>&lt;p&gt;One recommendation you often hear when reaching an acceptable level of basic&lt;br /&gt;
Haskell is to make your code more polymorphic. The Haskell &lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Prelude.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Prelude&lt;/code&gt;&lt;/a&gt; is&lt;br /&gt;
heavily biased towards lists, so an immediate gain in polymorphism is to make&lt;br /&gt;
your code work not only for lists but for any instance of &lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Data-Traversable.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Traversable&lt;/code&gt;&lt;/a&gt; or&lt;br /&gt;
&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Data-Foldable.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Foldable&lt;/code&gt;&lt;/a&gt;.&lt;sup id=&quot;fnref:a&quot;&gt;&lt;a href=&quot;#fn:a&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Since a Haskell list is an instance of &lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Data-Traversable.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Traversable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Data-Foldable.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Foldable&lt;/code&gt;&lt;/a&gt;, we can&lt;br /&gt;
still operate as usual on lists with the new polymorphic code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Foldable&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapM_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;c&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;&#39;b&#39;&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;&#39;c&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traverse_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&#39;c&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;&#39;a&#39;&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;&#39;b&#39;&lt;/span&gt;
&lt;span class=&quot;sc&quot;&gt;&#39;c&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice here that we’ve gained the extra advantage of being able to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Applicative&lt;/code&gt;&lt;br /&gt;
instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt;. Here, we don’t need the extra power of &lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt;, and the&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Applicative&lt;/code&gt;, by being weaker, is also more generalizable.&lt;/p&gt;

&lt;p&gt;But aside of lists, there is another instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;Traversable&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Foldable&lt;/code&gt;&lt;br /&gt;
defined by default for us: &lt;code class=&quot;highlighter-rouge&quot;&gt;Maybe&lt;/code&gt;. You could think of a &lt;code class=&quot;highlighter-rouge&quot;&gt;Maybe&lt;/code&gt; as a list of 1&lt;br /&gt;
or 0 elements, so when you are traversing it you either do something with the&lt;br /&gt;
element if present or do the default &lt;code class=&quot;highlighter-rouge&quot;&gt;Applicative&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Monad&lt;/code&gt; action (&lt;code class=&quot;highlighter-rouge&quot;&gt;pure&lt;/code&gt; and&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; respectively) if not present. How is this useful then? Have you ever&lt;br /&gt;
found yourself writing case expressions like this?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;                     &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;                     &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The function &lt;a href=&quot;http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#v:maybe&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;maybe&lt;/code&gt;&lt;/a&gt; would improve a bit, syntactically speaking: &lt;code class=&quot;highlighter-rouge&quot;&gt;maybe
(return ()) print&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Maybe it’s just me, but that &lt;code class=&quot;highlighter-rouge&quot;&gt;return ()&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_smell&quot;&gt;smells&lt;/a&gt; too much of a default&lt;br /&gt;
behavior to me. Somehow, there should be a way to avoid it. Well, here is where&lt;br /&gt;
&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Data-Foldable.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Foldable&lt;/code&gt;&lt;/a&gt; instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;Maybe&lt;/code&gt; comes handy:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;XScopedTypeVariables&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printM&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traverse_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printM&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printM&#39;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To be fair, for this trivial example, it would be a bit frivolous to use the&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Maybe&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Foldable&lt;/code&gt; instance just to avoid the case expression, but when you are&lt;br /&gt;
in an intricate case expression ladder, this idiom can make your code much more&lt;br /&gt;
readable.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:a&quot;&gt;
      &lt;p&gt;Roughly speaking, the &lt;code class=&quot;highlighter-rouge&quot;&gt;Traversable&lt;/code&gt; instance would be used for operations that do something on each element of the structure while maintaining same structure in the output. A &lt;code class=&quot;highlighter-rouge&quot;&gt;Foldable&lt;/code&gt; instance would be used for collapsing the elements into anything else. &lt;a href=&quot;#fnref:a&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 12 Mar 2014 12:00:00 +0100</pubDate>
        <link>http://dannynavarro.net/2014/03/12/improving-readability-with-the-maybe-foldable-instance/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2014/03/12/improving-readability-with-the-maybe-foldable-instance/</guid>
        
        
        <category>haskell</category>
        
      </item>
    
      <item>
        <title>Migrating to Octopress</title>
        <description>&lt;p&gt;I finally found some time to migrate my blog to &lt;a href=&quot;http://wordpress.com/&quot;&gt;Octopress&lt;/a&gt; from&lt;br /&gt;
&lt;a href=&quot;http://octopress.org/&quot;&gt;Wordpress.com&lt;/a&gt;. The critical reason to migrate from Wordpress has&lt;br /&gt;
been the support for nice code syntax highlighting, something I&lt;br /&gt;
couldn’t have wordpress.com, at least for free. I know there are very&lt;br /&gt;
nice wordpress plugins for syntax highlighting but in order to use&lt;br /&gt;
them I would have to host it myself. I don’t want to go through the&lt;br /&gt;
hassle of maintaining a typical PHP/MySQL stack or to be worried about&lt;br /&gt;
being &lt;a href=&quot;http://en.wikipedia.org/wiki/Slashdotted&quot;&gt;&lt;em&gt;slashdotted&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Having worked with an excellent documentation tool like &lt;a href=&quot;http://sphinx.pocoo.org/&quot;&gt;Sphinx&lt;/a&gt;, I&lt;br /&gt;
started looking to static blog generators meant. It turned out that&lt;br /&gt;
&lt;a href=&quot;http://blog.manuelviera.es/&quot;&gt;Manu Viera&lt;/a&gt;, a colleague working at &lt;a href=&quot;http://www.yaco.es/&quot;&gt;Yaco&lt;/a&gt; with me, shared the&lt;br /&gt;
same itch and had already looked several static web generators in&lt;br /&gt;
Python, which is our main language at &lt;a href=&quot;http://www.yaco.es/&quot;&gt;Yaco&lt;/a&gt;. Manu found&lt;br /&gt;
&lt;a href=&quot;https://github.com/ametaireau/pelican&quot;&gt;pelican&lt;/a&gt; the best candidate but still I found it a bit immature,&lt;br /&gt;
not something like something like &lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then I found &lt;a href=&quot;http://wordpress.com/&quot;&gt;Octopress&lt;/a&gt;, a framework built on top of &lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;&lt;br /&gt;
with &lt;a href=&quot;http://octopress.org/docs/plugins/&quot;&gt;several plugins&lt;/a&gt;, including syntax highlighting or automatic&lt;br /&gt;
support for &lt;a href=&quot;http://disqus.com/&quot;&gt;disqus&lt;/a&gt; comments.&lt;/p&gt;

&lt;p&gt;The migration from wordpress was not too painful. I used the default&lt;br /&gt;
Jekyll script to import wordpress posts and disqus importer for the&lt;br /&gt;
comments.  After some sed commands I got nice markdown formatted&lt;br /&gt;
scripts.&lt;/p&gt;

&lt;p&gt;I had some trouble in the beginning configuring an isolated Ruby&lt;br /&gt;
runtime in &lt;a href=&quot;http://archlinux.org/&quot;&gt;Arch Linux&lt;/a&gt; just for Octopress but after discovering&lt;br /&gt;
&lt;a href=&quot;https://github.com/sstephenson/rbenv&quot;&gt;rbenv&lt;/a&gt;, everything went smooth. (I prefer rbenv instead RVM with&lt;br /&gt;
rbenv I know at any moment what it’s doing).&lt;/p&gt;

&lt;p&gt;Deploying an Octopress generated site to &lt;a href=&quot;http://pages.github.com/&quot;&gt;github pages&lt;/a&gt; is as&lt;br /&gt;
&lt;a href=&quot;http://octopress.org/docs/deploying/index.html&quot;&gt;easy&lt;/a&gt; as pie.&lt;/p&gt;

&lt;p&gt;Aside of nice Python syntax highlighting now I have some extra&lt;br /&gt;
advantages I didn’t have with wordpress.com:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Markdown syntax when writing my posts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I can use the best text editor to mankind: &lt;a href=&quot;http://www.vim.org/&quot;&gt;vim&lt;/a&gt; :P&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My blog data becomes more manageable. If at some point I don’t want&lt;br /&gt;
to host it github, I could just to push it somewhere else with no&lt;br /&gt;
modification.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I got a very nice default theme for free, that aside of looking&lt;br /&gt;
good, it’s also very easy to tweak and maintain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now I have a good excuse to learn Ruby outside of RoR influence.&lt;br /&gt;
Ruby is one of those languages I wish I would be better at, even if&lt;br /&gt;
Python remains my main working language.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In any case, I must say the service provided by wordpress.com has been&lt;br /&gt;
quite good but this one of those cases where you have to say: &lt;em&gt;“Sorry,&lt;br /&gt;
it’s not you, it’s just me”.&lt;/em&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Sep 2011 19:07:00 +0200</pubDate>
        <link>http://dannynavarro.net/2011/09/20/migrating-to-octopress/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2011/09/20/migrating-to-octopress/</guid>
        
        
        <category>blogging</category>
        
        <category>migration</category>
        
        <category>personal</category>
        
        <category>hacking</category>
        
      </item>
    
      <item>
        <title>Using custom events in Pyramid</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://docs.pylonsproject.org/docs/pyramid.html&quot;&gt;Pyramid&lt;/a&gt; is a &lt;a href=&quot;http://webpython.codepoint.net/wsgi_tutorial&quot;&gt;WSGI&lt;/a&gt; application framework that primarily follows a&lt;a href=&quot;http://docs.pylonsproject.org/projects/pyramid/1.0/narr/router.html&quot;&gt; request-response mechanism&lt;/a&gt;. However, if you need to work with events you can still &lt;a href=&quot;http://docs.pylonsproject.org/projects/pyramid/1.0/narr/events.html&quot;&gt;use them&lt;/a&gt;. It comes with &lt;a href=&quot;http://docs.pylonsproject.org/projects/pyramid/1.0/api/events.html#event-types&quot;&gt;some default event types&lt;/a&gt; that are emitted implicitely by Pyramid as long as you have a subscriber for them. For most applications the default event types are enough, but what if you want to write your custom event type and emit it explicitly from your code? It turns out that the &lt;a href=&quot;http://docs.pylonsproject.org/projects/pyramid/1.0/glossary.html#term-application-registry&quot;&gt;application registry&lt;/a&gt; that Pyramid uses by default comes with a handy &lt;a href=&quot;https://github.com/Pylons/pyramid/blob/master/pyramid/registry.py#L36&quot;&gt;&lt;em&gt;notify&lt;/em&gt; method&lt;/a&gt;. Pyramid &lt;a href=&quot;https://github.com/Pylons/pyramid/blob/master/pyramid/router.py#L77&quot;&gt;uses this method internally&lt;/a&gt;  for its default events. Here is how you would take advantage of it:&lt;/p&gt;
&lt;pre&gt;from pyramid.events import subscriber

class MyCustomEventType(object):
    def __init__(self, msg):
        self.msg = msg

@subscriber(MyCustomEventType)
def my_subscriber(event):
    print(event.msg)

def my_view(request):
    request.registry.notify(MyCustomEventType(&quot;Here it comes&quot;))
    return {}
&lt;/pre&gt;

&lt;p&gt;When running the application, every time a request goes through &lt;em&gt;my_view,&lt;/em&gt; an event with a message is emitted, in this case, “Here it comes”. The subscriber then handles the event by printing the message, but it could do anything you want.&lt;/p&gt;

&lt;p&gt;Notice that I’m using a &lt;a href=&quot;http://docs.pylonsproject.org/projects/pyramid/1.0/narr/events.html#configuring-an-event-listener-using-a-decorator&quot;&gt;decorator to hook&lt;/a&gt; &lt;em&gt;my_subscriber&lt;/em&gt;. In order for the decorator to work you have to make sure you &lt;a href=&quot;http://docs.pylonsproject.org/projects/pyramid/1.0/narr/configuration.html#configuration-decorations-and-code-scanning&quot;&gt;call the &lt;em&gt;scan&lt;/em&gt; method when configuring&lt;/a&gt; the application.&lt;/p&gt;

&lt;p&gt;Be aware though, that all these events are synchronous because Pyramid is primarily a request-response framework, all the events emitted block until the subscribers are done. If you want non-blocking events in Pyramid you could spawn a process from the subscriber or come with &lt;a href=&quot;http://blog.dannynavarro.net/2011/01/14/async-web-apps-with-pyramid/&quot;&gt;some other solution&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But the events in Pyramid are just another functionality that it offers. Pyramid is not a event-oriented framework, if you want to go all the way with async events you should look into &lt;a href=&quot;http://twistedmatrix.com/trac/&quot;&gt;Twisted&lt;/a&gt; or &lt;a href=&quot;http://www.tornadoweb.org/&quot;&gt;Tornado&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Jun 2011 00:00:00 +0200</pubDate>
        <link>http://dannynavarro.net/2011/06/12/using-custom-events-in-pyramid/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2011/06/12/using-custom-events-in-pyramid/</guid>
        
        
        <category>hacking</category>
        
        <category>pyramid</category>
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Why Arch Linux</title>
        <description>&lt;p&gt;I have been using &lt;a href=&quot;http://www.archlinux.org/&quot;&gt;Arch Linux&lt;/a&gt; for 3 years now. I still use Debian and Ubuntu for the servers I administer but I acknowledge Arch Linux has taught many valuable lessons.&lt;/p&gt;

&lt;p&gt;With Arch Linux there is very little in your system that you are not aware of. You have to configure everything yourself by editing config files. The process is not that hard because all those configuration files are meant to be tweaked. You also count with an &lt;a href=&quot;https://wiki.archlinux.org&quot;&gt;excellent wiki&lt;/a&gt; to help you.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://wiki.archlinux.org/index.php/The_Arch_Way&quot;&gt;Arch Linux philosophy&lt;/a&gt; doesn’t try to shield the user from complexity with extra layers. Instead it focuses on making the direct configuration as simply as possible. For example, writing a proper boot script is much straightforward than in other distros. At the same time if you are not careful you have more chances of really screw things up everything.&lt;/p&gt;

&lt;p&gt;Arch Linux aggressively updates from upstream sources. This has the advantage and disadvantages of being always in the bleeding-edge. I also like the idea of putting more responsibility about the stability of software in developers than in packagers, as long as you are aware of this as a user. As a user you have to assume the responsibility of being at the cutting-edge. Things may not go always smooth but you count with excellent tools to manage chaos.&lt;/p&gt;

&lt;p&gt;That brings me to the real killer feature that makes Arch Linux shine over the rest: the packaging system. &lt;a href=&quot;https://wiki.archlinux.org/index.php/Pacman&quot;&gt;Pacman&lt;/a&gt;, &lt;a href=&quot;https://wiki.archlinux.org/index.php/ABS&quot;&gt;ABS&lt;/a&gt;, &lt;a href=&quot;https://wiki.archlinux.org/index.php/AUR&quot;&gt;AUR&lt;/a&gt;, &lt;a href=&quot;https://wiki.archlinux.org/index.php/Makepkg&quot;&gt;makepkg&lt;/a&gt; and the &lt;a href=&quot;https://wiki.archlinux.org/index.php/PKGBUILD&quot;&gt;PKGBUILD&lt;/a&gt; format are just great. You usually don’t have to mess with packaging that much, everything installs nicely and dependencies are correctly handled, specially if you stick to the official repository.&lt;/p&gt;

&lt;p&gt;But if you don’t like something about a package or need another version you have all the tools in place for the creation and introspection of packages without disrupting pacman bookkeeping (pacman is the equivalent of dpkg/apt-get in Debian).  Let me illustrate all this with something I had to deal with this week.&lt;/p&gt;

&lt;p&gt;I decide to use &lt;a href=&quot;http://compass-style.org/blog/&quot;&gt;Compass&lt;/a&gt; to make my stormy relationship with CSS smoother. Compass is a Ruby gem, the usual way to install gems is through Ruby packaging system but I don’t want to mess with the Ruby libraries already installed in the system with pacman. If I install those gems as root pacman will not be able to keep track of them, everything could break in the future, and most importantly, without an easy solution.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://rhodesmill.org/brandon/2011/adding-compass/&quot;&gt;A way&lt;/a&gt; to deal with this issue is to install the Compass gem in some directory and handle the runtime somehow. You usually end up with a new runtime environment for each project you start. There are excellent tools to manage runtimes in Ruby like &lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rake&lt;/a&gt;, but boy, I already have enough &lt;a href=&quot;http://www.doughellmann.com/projects/virtualenvwrapper/&quot;&gt;managing&lt;/a&gt; my Python &lt;a href=&quot;http://pypi.python.org/pypi/virtualenv&quot;&gt;virtualenvs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I see that Compass is already in AUR. &lt;a href=&quot;http://aur.archlinux.org/&quot;&gt;AUR&lt;/a&gt; is a very liberal package repository where anyone can upload source packages. When you install from AUR you usually have a review the PKGBUILD, the comments of other users and check how many users have voted the package to be included in official repositories. With tools like &lt;a href=&quot;https://wiki.archlinux.org/index.php/Yaourt&quot;&gt;yaourt&lt;/a&gt; the whole process is very smooth.&lt;/p&gt;

&lt;p&gt;Alright, the ruby-compass PKGBUILD looks good to me so I install it. Now compass is a good system citizen and can be updated, installed and uninstalled through pacman. Compass works as expected but it turns out that the most interesting feature I wanted to use in Compass is only available in the latest version of Compass, the version in AUR is not the latest one.&lt;/p&gt;

&lt;p&gt;No problem, it’ll probably be some version bumps and I’ll be done. I download the PKGBUILD, bump the versions and build the package again but then I realize that the new version depends on new Ruby gems that are not in AUR.&lt;/p&gt;

&lt;p&gt;At this point I would avoid getting into a dependency hell and go for Rake, but wait, I’m using Arch Linux, let’s see what happens if I continue with the Arch flow.&lt;/p&gt;

&lt;p&gt;I take the PKGBUILD of Compass as a template, which is generic enough for any Ruby gem, and use them for the Ruby dependencies. I update licences, versions checksums, build them and done, everything works. They are all coming from &lt;a href=&quot;http://rubyforge.org/&quot;&gt;rubyforge&lt;/a&gt; and follow the same building conventions, making my life easy as a packager.&lt;/p&gt;

&lt;p&gt;I upload the PKGBUILDs to AUR with just one &lt;a href=&quot;https://bbs.archlinux.org/viewtopic.php?id=97137&quot;&gt;burp&lt;/a&gt; command. Now I can install the latest version of compass through pacman without any issue. I then send my modified version of PKGBUILD to the original Compass packager who updates it. That’s it, now anyone can install the latest version of Compass with all its dependencies from AUR. I now can install Compass at home with just one command: just &lt;em&gt;yaourt -Sy ruby-compass.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now I just have to keep an eye in new updates on the dependencies I’m now maintaining in AUR but rubyforge offers an excellent notification system for gem updates.&lt;/p&gt;

&lt;p&gt;That’s it. The whole thing took less than 30 minutes.&lt;/p&gt;

&lt;p&gt;I don’t know if nowadays writing a DEB package spec is that hard, I acknowledge I never tried. The tutorials I found about them drove me away when I considered it some years ago.&lt;/p&gt;

&lt;p&gt;It’s not only the packaging format itself, there is also the community and policy aspects. Editing your PKGBUILDs is something that every Arch Linux user does. For AUR there is very little regulating making the packaging smoother process at the expense of shifting the trust on the packages to the user. In general, most packages in AUR are good enough but for production machines I still value more the trust the Debian and Ubuntu package maintainers.&lt;/p&gt;

&lt;p&gt;That’s where open source community shines, you have many choices.&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2011 00:00:00 +0200</pubDate>
        <link>http://dannynavarro.net/2011/05/21/why-arch-linux/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2011/05/21/why-arch-linux/</guid>
        
        
        <category>archlinux</category>
        
        <category>hacking</category>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Commenting out in Chamaleon templates</title>
        <description>&lt;p&gt;If you want to prevent &lt;a href=&quot;http://chameleon.repoze.org/&quot; title=&quot;Chameleon is an excellent HTML templating engine&quot;&gt;Chameleon&lt;/a&gt; from rendering some portions of an HTML template you might be tempted to do something like this:&lt;/p&gt;

&lt;pre&gt;

&amp;lt;!-- &amp;lt;div&amp;gt;${context.name}&amp;lt;/div&amp;gt; --&amp;gt;

&lt;/pre&gt;

&lt;p&gt;However Chameleon will still evaluate what’s inside the ${…} block even if it’s within an HTML comment. Chameleon must do this because you might want to insert conditional comments.&lt;/p&gt;

&lt;p&gt;This dummy tal:condition block will do the job:&lt;/p&gt;

&lt;pre&gt;

&amp;lt;span tal:condition=&quot;None&quot;&amp;gt;
  &amp;lt;div&amp;gt;${context.name}&amp;lt;/div&amp;gt;
&amp;lt;/span&amp;gt;

&lt;/pre&gt;

&lt;p&gt;Chameleon ignore anything inside the condition block.&lt;/p&gt;
</description>
        <pubDate>Wed, 18 May 2011 00:00:00 +0200</pubDate>
        <link>http://dannynavarro.net/2011/05/18/commenting-out-in-chamaleon-templates/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2011/05/18/commenting-out-in-chamaleon-templates/</guid>
        
        
        <category>chameleon</category>
        
        <category>hacking</category>
        
        <category>html</category>
        
        <category>pyramid</category>
        
        <category>templating</category>
        
      </item>
    
      <item>
        <title>Moving to Spain</title>
        <description>&lt;p&gt;After almost 3 years in The Netherlands working as &lt;a href=&quot;http://en.wikipedia.org/wiki/Proteomics&quot;&gt;proteomics&lt;/a&gt; informatician at &lt;a href=&quot;http://bioms.chem.uu.nl/&quot;&gt;Albert Heck’s lab&lt;/a&gt;, I’m moving to &lt;a href=&quot;http://en.wikipedia.org/wiki/Sevilla&quot;&gt;Seville&lt;/a&gt;, Spain, to work as a web developer for&lt;a href=&quot;http://yaco.es/&quot;&gt; Yaco Sistemas&lt;/a&gt;, a fresh and dynamic open source friendly company.&lt;/p&gt;

&lt;p&gt;This is an important shift in my career since I won’t be working on proteomics informatics and academic research anymore. I have mixed feelings about leaving proteomics. On one hand I like the area because there are plenty of tough challenges to be solved. But on the other hand I’m glad I can dedicate all my time to develop web applications, that might not be as sophisticated as proteomics software, but that will be immediately useful for the &lt;em&gt;masses&lt;/em&gt;. I love web development and the Python community but within proteomics I could only intersect with the Python web development community quite sporadically. Now I’ll have the chance to be part of it full time.&lt;/p&gt;

&lt;p&gt;Personally, The Netherlands is the most comfortable and easy-going country I ever lived. Here I had the chance to work with very smart people and made friends that will never forget. What I have learned during these years is priceless.&lt;/p&gt;

&lt;p&gt;But I can’t deny my origins, Spain is where I feel at home even if sometimes I don’t find it too exciting because I’m too familiar with the culture. However Seville is quite far from &lt;a title=&quot;Pamplona&quot; href=&quot;http://en.wikipedia.org/wiki/Pamplona&quot;&gt;my hometown&lt;/a&gt;, in the North of Spain. The culture in the South is very different from the North, so in a way, I’ll be another foreigner excited about the peculiarities I discover about Andalusian culture.&lt;/p&gt;
</description>
        <pubDate>Sun, 15 May 2011 00:00:00 +0200</pubDate>
        <link>http://dannynavarro.net/2011/05/15/moving-to-spain/</link>
        <guid isPermaLink="true">http://dannynavarro.net/2011/05/15/moving-to-spain/</guid>
        
        
        <category>personal</category>
        
        <category>spain</category>
        
        <category>yaco</category>
        
      </item>
    
  </channel>
</rss>
